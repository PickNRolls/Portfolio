// Generated by CoffeeScript 2.0.1
(function() {
  var Particle, ParticleCircle, Vec2, World, _Object, world,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  Vec2 = class Vec2 {
    constructor(x, y) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
    }

    add(vec) {
      var ref, ref1, ref2, ref3;
      if (arguments[1] !== void 0) {
        this.x += (ref = arguments[0]) != null ? ref : 0;
        this.y += (ref1 = arguments[1]) != null ? ref1 : 0;
        return this;
      }
      this.x += (ref2 = vec.x) != null ? ref2 : 0;
      this.y += (ref3 = vec.y) != null ? ref3 : 0;
      return this;
    }

    copy() {
      return new Vec2(this.x, this.y);
    }

  };

  World = class World {
    constructor(canvas) {
      this.canvas = canvas;
      this._canvasWidth = this.canvas.width = window.innerWidth;
      this._canvasHeight = this.canvas.height = window.innerHeight;
      this.ctx = this.canvas.getContext('2d');
      this._objects = [];
    }

    addObject(constructor, config) {
      var obj;
      config.world = this;
      obj = new constructor(config);
      return this._objects.push(obj);
    }

    start() {
      if (this._objects.length === 0) {
        throw new Error('No objects to draw!');
      }
      return this.tick();
    }

    tick() {
      this.update();
      this.draw();
      return requestAnimationFrame(this.tick.bind(this));
    }

    update() {
      var j, len, object, ref, results;
      ref = this._objects;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        object = ref[j];
        results.push(object.update());
      }
      return results;
    }

    draw() {
      var j, len, object, ref, results;
      this.ctx.fillStyle = 'rgba(255, 255, 255, .07)';
      this.ctx.fillRect(0, 0, this._canvasWidth, this._canvasHeight);
      ref = this._objects;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        object = ref[j];
        results.push(object.draw());
      }
      return results;
    }

    static randomIntBetween(min, max) {
      return Math.round(Math.random() * (max - min) + min);
    }

  };

  _Object = class _Object {
    constructor(config) {
      var ref;
      this.world = config.world;
      this._loc = (ref = config.loc) != null ? ref : new Vec2;
    }

    update() {
      throw new Error('Method must be overriden');
    }

    draw() {
      throw new Error('Method muse be overriden');
    }

  };

  ParticleCircle = class ParticleCircle extends _Object {
    constructor(config) {
      var ref, ref1, ref2, ref3, ref4;
      super(config);
      //#########
      // Events #
      //#########
      this.move = this.move.bind(this);
      this.randomColors = (ref = config.randomColors) != null ? ref : ['#222831', '#393e46', '#f96d00', '#fff1c5', '#f2f2f2'];
      this._color = (ref1 = config.color) != null ? ref1 : '#fff';
      this._velocity = (ref2 = config.velocity) != null ? ref2 : .02;
      this._particleAmount = (ref3 = config.particleAmount) != null ? ref3 : 6;
      this._particleRadius = (ref4 = config.particleRadius) != null ? ref4 : 5;
      this._particles = [];
      this.init();
    }

    init() {
      var i, j, ref;
      for (i = j = 0, ref = this._particleAmount; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        this.addParticle({
          loc: this._loc.copy(),
          radius: this._particleRadius,
          color: this._color,
          velocity: this._velocity
        }, i);
      }
      return this.world.canvas.addEventListener('mousemove', this.move);
    }

    addParticle(config, ind) {
      config.particleCircle = this;
      return this._particles.push(new Particle(config, ind));
    }

    update() {
      var j, len, particle, ref, results;
      ref = this._particles;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        particle = ref[j];
        results.push(particle.update());
      }
      return results;
    }

    draw() {
      var j, len, particle, ref, results;
      ref = this._particles;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        particle = ref[j];
        results.push(particle.draw());
      }
      return results;
    }

    move(e) {
      var j, len, particle, ref, results;
      boundMethodCheck(this, ParticleCircle);
      ref = this._particles;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        particle = ref[j];
        results.push(particle.move(e));
      }
      return results;
    }

  };

  Particle = class Particle extends _Object {
    constructor(config, ind) {
      super(config);
      this.particleCircle = config.particleCircle;
      this.world = this.particleCircle.world;
      this._radius = config.radius;
      this._velocity = config.velocity / 100;
      this._radians = Math.random() * 2 * Math.PI;
      this._distanceFromCenter = Math.random() * (125 - 50) + 50;
      if (config.color === 'random') {
        this._color = this.particleCircle.randomColors[World.randomIntBetween(0, this.particleCircle.randomColors.length)];
      } else {
        this._color = config.color;
      }
      this._initLoc = config.loc.copy();
      this._lastLoc = new Vec2;
      this._mouseLoc = config.loc.copy();
      this._lastMouseLoc = config.loc.copy();
    }

    update() {
      this._lastLoc.x = this._loc.x;
      this._lastLoc.y = this._loc.y;
      this._lastMouseLoc.x += (this._mouseLoc.x - this._lastMouseLoc.x) * 0.05;
      this._lastMouseLoc.y += (this._mouseLoc.y - this._lastMouseLoc.y) * 0.05;
      this._radians += this._velocity;
      this._loc.x = this._lastMouseLoc.x + Math.cos(this._radians) * this._distanceFromCenter;
      return this._loc.y = this._lastMouseLoc.y + Math.sin(this._radians) * this._distanceFromCenter;
    }

    draw() {
      this.world.ctx.beginPath();
      this.world.ctx.strokeStyle = this._color;
      this.world.ctx.lineWidth = this._radius;
      this.world.ctx.moveTo(this._lastLoc.x, this._lastLoc.y);
      this.world.ctx.lineTo(this._loc.x, this._loc.y);
      this.world.ctx.stroke();
      return this.world.ctx.closePath();
    }

    //#########
    // Events #
    //#########
    move(e) {
      this._mouseLoc.x = e.offsetX;
      this._mouseLoc.y = e.offsetY;
      this._initLoc.x = this._mouseLoc.x;
      return this._initLoc.y = this._mouseLoc.y;
    }

  };

  world = new World(document.getElementById('canvas'));

  world.addObject(ParticleCircle, {
    loc: new Vec2(300, 300),
    color: 'random',
    particleAmount: 160,
    particleRadius: 2,
    velocity: 4
  });

  window.world = world;

  world.start();

}).call(this);
